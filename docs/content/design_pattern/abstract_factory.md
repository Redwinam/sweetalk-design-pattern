# 抽象工厂模式

## 设计动机

**问题引入**

数据库是应用中不可缺少的组件，假设我们的应用最开始时使用 MySQL，但是某一天突然需要接一个 Access，两个数据库在很多方面都不相同，原来的创建、更新、删除、查询相关代码都需要修改。最简单的方案是直接针对 Access 重新写一套，最外面用一个参数来判断是使用哪种库，并路由到对应的逻辑。

但是好景不长，又接到了一个 Oracle，这时候怎么办，再写一套新的，再多一个判断分支？当然也未尝不可。但这种情况已经出现两次了，聪明的你可能已经意识到了，万一过几天再来一个新的怎么办，干脆将业务逻辑和具体的库隔离开。具体来说，就是把增删改查的逻辑抽离出来，与实际的数据库解耦，我们通过新创建一个对应数据库的工厂，该工厂新建、更新和删除的每张表都是与该数据库相对应的，它们都接受相同的业务参数。

**模式引入**

刚刚提到的方案就是抽象工厂模式，当有多个产品或相关产品系列时，通过组合的方式将创建对象的任务委托给其他类，可以保证多个或系列产品的一致性。也使得交换产品系列更加方便，一个具体工厂只在初始化时出现一次，只需修改这里就可以使用不同的产品配置。

## 模式介绍

抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。它是一般化的工厂方法，可以看做一组工厂方法的集合。

**实现方式**

- 可以借助反射使用变量来初始化不同产品，以减少显式、固定地分支判断。
- 可以根据需要与简单工厂、工厂方法结合起来使用。
- 一般不在开发初期使用，通常从简单工厂或工厂方法开始。

**模式结构**

![](img/abstract_factory/abstract_factory.jpeg)

**代码实现**

- C++ 实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/cpp/abstract_factory)
- Java 实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/java/abstract_factory)
- Python 实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/python/abstract_factory)

## 使用场景

**适合场景**

- 需要使用大量工厂方法生产系列产品时。
- 需要独立于产品的创建、组合和表示时。
- 需要将产品类库的接口和实现分离时。

**实际应用**

实际中的例子：极少扩展的产品系列。

- 数据库。
- 标准用户界面工具包。
- 汽车部件。
- 游戏环境。

## 模式评价

**模式优点**

- 将产品和生成产品分开，工厂不同，产品不同，易于维护。
- 具体实例创建与客户端解耦，客户端不关心具体工厂。

**不足之处**

- 难以支持新种类的产品，因为扩展新类需要扩展工厂接口，涉及到所有子类的改变。