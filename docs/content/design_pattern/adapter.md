# 适配器模式

## 设计动机

**问题引入**

想象我们要出国旅游，到了异国他乡不懂当地语言怎么办？路上卯足马力突击学习？当然可以！不过更简单的做法是，打开手机翻译软件，切换到「当地语言-中文」就可以借助它与当地人进行对话了。这样，只要我们手机里有其他语言与中文的互译，就可以走遍地球任意一个角落并和当地人沟通了，而且我们自己并不需要真正掌握任何一门外语。

**模式引入**

这就是适配器模式，它一般在有满足需求功能的类，但接口不符合要求，或者希望创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类协同工作时出现。总的来说，它的主要目的是希望能复用已有的类，但接口又与复用环境要求不一致。

上面的例子中，中文与其他语言的互译器就是一个个适配器，我们自己就是那个已有的满足功能的类，接口和环境就是异国他乡。

## 模式介绍

**模式定义**

适配器模式是将一个类的接口转换成客户希望的另外一个接口。使得原来接口不兼容的类可以一起工作。

**实现方式**

- 一般在开发后期或维护期，双方都比较稳定、不太容易修改时候才会使用。

**模式结构**

![](img/adapter/adapter.jpeg)

**代码实现**

- C++ 实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/cpp/adapter)
- Java 实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/java/adapter)
- Python 实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/python/adapter)

## 使用场景

**适合场景**

- 系统数据和行为正确，但接口不符时。
- 扩展新功能接入第三方接口时。

**实际应用**

实际中的例子：复用功能但接口不符，俗称包一层。

## 模式评价

**模式优点**

- 接口与业务逻辑解耦。
- 容易扩展。

**不足之处**

- 代码复杂度增加。

