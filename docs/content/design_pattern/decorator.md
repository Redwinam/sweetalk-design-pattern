# 装饰模式

## 1 问题引入

### 1.1 问题描述

&emsp;&emsp;小菜要去约会，和大鸟聊到穿衣问题。大鸟由穿衣问题引申，要求用C++、Java、python、C#任意一种面向对象语言实现一个可以给人搭配嘻哈服或白领装的系统。

&emsp;&emsp;进一步地，对系统实现超人装扮的添加。

### 1.2 问题分析

&emsp;&emsp;实现该目标的程序同时需满足
1. 面向对象。
2. 装扮过程应该在内部实现（因为衣服不能在众目睽睽之下穿），服饰的装扮先后顺序及装扮组合有多种，**需要把所需的功能按正确顺序串联起来进行控制**。

### 1.3 解决方案

&emsp;&emsp;此时可以考虑使用`装饰模式`来解决问题。
1. 创建抽象的接口类`Component`，定义给对象动态添加职责的公共接口（在此例中，由于具体的接口只有一个，所以该步也可省略）；
2. 创建具体的接口`Person`(Concrete Component)，继承于抽象接口类`Component`，定义方法`Show()`用于显示装扮结果；
3. 创建抽象的装饰类`Finery`（Decorator），继承于接口类`Person`（一般来说继承于抽象接口类`Component`，由于此例只有一个接口，故继承于具体接口类），定义方法`Decorate(component)`用于进行装扮过程，覆写`Show()`具体装扮结果的显示；
4. 创建系列具体的服饰类（Concrete Decorator），如`Tshirts`，`BigTrouser`等，继承于抽象装饰类`Finery`，实现具体的装饰对象，覆写`Show()`具体装扮结果的显示。

### 1.4 代码实现

* C++语言实现：[链接]("/../../../../src/design_patterns/cpp/decorator/")
* Java语言实现：[链接]("/../../../../src/design_patterns/java/decorator/")
* python语言实现：[链接]("/../../../../src/design_patterns/python/decorator/DecoratorFinery.py")
* C#语言实现见原书第二版。

## 2 模式介绍

### 2.1 定义

&emsp;&emsp;装饰模式（Decorator Pattern）是指创建一个装饰类，来包装原有的类，从而实现向一个现有的对象添加一些额外的职责，同时不改变其原有的结构。

### 2.2 结构


## 3 适用场景

&emsp;&emsp;可以在不生成很多子类的情况下扩展类，适用于扩展类需求较多，而又不想引起子类膨胀的场景。

## 4 评价

### 4.1 优点

* 把类中的装饰功能从类中搬移去除，很好地简化了原有的类；
* 有效地把类的核心职责和装饰功能区分开了，可以去除相关类中重复的装饰逻辑。

### 4.2 缺点

