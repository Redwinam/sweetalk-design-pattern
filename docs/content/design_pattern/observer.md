# 观察者模式

## 设计动机

**问题引入**

我们设想一个场景，假设公司几个同事日常喜欢工作摸鱼，但又怕被自己领导或老板发现，怎么办呢？他们只好每隔几分钟就起来看看老板或者自己的领导有没有回来。这很不方便，想象一下，如果有几十个同事在摸鱼（这公司怕是要倒闭了），大家总不能跟赶集一样，隔几分钟就起来走几步吧。

此时，有人突拍大腿：为啥不整个吹哨人呢，比如前台小妹子？如果老板来了，她只需给我们发个微信消息通知一下就行了呀——有道理！先建个群把大家都拉进去，有领导来了就让前台小妹发消息。过了几天，有人不满意了：我们领导一周都不来，还老是收到消息，搞得我们心惊胆战的，还得分开注意力看一下手机，不知道敌方正在上高地吗，能不能我们领导来了再发消息。

这时又有聪明人出招了，前台小妹先创建好所有领导的群，把二维码全部发出来，你想收到哪个领导来的消息，自己加对应的群。这下方便了，只要消息来了就知道是自己领导来了，赶紧采取行动。而且，如果这会儿突然不想摸鱼了，那把消息屏蔽了就行，明天又想摸鱼，把消息屏蔽取消就可以了。皆大欢喜。

**模式引入**

用程序术语来说，将系统分割成一系列相互协作的类有个很不好的副作用，就是需要维护相关对象间的一致性。为了维护所需的一致性又不至于使各类紧密耦合，导致维护和扩展的不便，引入观察者模式。

观察者模式的关键对象是主题 Subject 和观察者 Observer，一个 Subject 可以有多个 Observer，它不关心到底有哪些 Observer，Observer 之间也不需要知道彼此存在。当 Subject 的状态发生变化时，所有的 Observer 都会得到通知。当然，反过来一个 Observer 可以订阅多个 Subject，任意一个 Subject 的状态发生变化，该 Observer 都会得到通知。这样就既解决了一致性问题，又不会过紧耦合。

上面的例子中，针对各个领导的群就是 Subject，员工则是 Observer。

## 模式介绍

**模式定义**

观察者模式又叫发布-订阅（Publish/Subscribe）模式。它定义了一种**一对多**的依赖关系，多个观察者对象同时监听一个主题对象。当该主题对象的**状态发生变化**时，所有的观察者都会得到**通知并自动更新**。它描述了单个对象和一个或多个对象之间的发布-订阅关系。

**实现方式**

有两种方式可以实现通知：

- 推模型：Subject 起主导作用，向 Observer 推送。
- 拉模型：Subject 对变化进行广播，由 Observer 负责拉取更新。

**模式结构**

![](img/observer/observer.jpeg)

**代码实现**

- C++ 实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/cpp/observer)
- Java 实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/java/observer)
- Python 实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/python/observer)

## 使用场景

**适合场景**

- 当一个对象的改变需要同时改变多个（不知道具体数目）对象时。
- 当一个抽象模型的两个方面一方依赖于另一方时，将两者封装在独立的对象中。

**实际应用**

实际中的例子：批量自动更新。

- RSS 之类的订阅应用。
- 消息、通知类应用。
- 竞拍、股票类应用。

## 模式评价

**模式优点**

- Subject 和 Observer 之间松耦合，可以轻松扩展。
- 支持广播通信，不需要指定接收者，而且可以随时增删 Observer。

**不足之处**

- 不同的订阅者可能需要不同的更新（功能），而不是所有的都一样。
- Subject 依赖于 Observer 对抽象接口的实现，没有实现就无法通知。



