# 观察者模式

观察者模式又叫发布-订阅（Publish/Subscribe）模式。它定义了一种**一对多**的依赖关系，多个观察者对象同时监听一个主题对象。当该主题对象的**状态发生变化**时，所有的观察者都会得到**通知并自动更新**。它描述了单个对象和一个或多个对象之间的发布-订阅关系。

**设计动机**

将系统分割成一系列相互协作的类有个很不好的副作用，就是需要维护相关对象间的一致性。

为了维护所需的一致性又不至于使各类紧密耦合，导致维护和扩展的不便，引入观察者模式。

观察者模式的关键对象是主题 Subject 和观察者 Observer，一个 Subject 可以有多个 Observer，它不关心到底有哪些 Observer，Observer 之间也不需要知道彼此存在。当 Subject 的状态发生变化时，所有的 Observer 都会得到通知。

这样就既解决了一致性问题，又不会过紧耦合。

**使用场景**

- 当一个对象的改变需要同时改变多个（不知道具体数目）对象时。
- 当一个抽象模型的两个方面一方依赖于另一方时，将两者封装在独立的对象中。

实际中的例子：批量自动更新。

- RSS 之类的订阅应用。
- 消息、通知类应用。
- 竞拍、股票类应用。

**不足之处**

- 不同的订阅者可能需要不同的更新（功能），而不是所有的都一样。
- Subject 依赖于 Observer 对抽象接口的实现，没有实现就无法通知。

**实现方式**

有两种方式可以实现通知：

- 推模型：Subject 起主导作用，向 Observer 推送。
- 拉模型：Subject 对变化进行广播，由 Observer 负责拉取更新。

![](img/observer/observer.jpeg)

