# 原型模式

<div class="side-by-side-container">
<div class="side-by-side-panel">
<div class="side-by-side-header">📖 原文</div>
<div class="side-by-side-content">

## 模式引入

### 问题描述

设想我们需要给不同时间点的自己写三份简历，此时姓名和性别等信息是不变的，只有年龄和工作经历（工作经历包含时间区间和公司名称的属性）有稍许变化。

进行多次实例化，会降低性能。如果能在克隆基础上，做少许更改就好了！

### 模式定义

`原型模式（Prototype）`是创建型模式的一种。它用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

- 通过**复制**一个已存在的实例，返回新的实例（没有新建实例），**原型**指被复制的实例；
- 实现克隆操作，必须实现 Cloneable 接口。

### 问题分析

- 客户端代码，在生成三份简历时，应当避免多次执行初始化操作。

  > 一般在初始化信息不发生变化的情况下，克隆是较好的方法。它既隐藏了对象创建的细节，又提升了性能。

- 浅复制和深复制：

  (1) 浅复制：可以复制值类型；但对于引用类型，只复制引用，不复制引用的对象。

  > 例如：简历类中有"设置工作经历"的方法，通常"工作经历"类有"时间区间"和"公司名称"等属性。如果简单 Clone 简历类，那么"工作经历"中的属性不会被复制。

  (2) 深复制：对于引用类型，也会复制一份新对象，而不是只复制引用。

  > 例如："工作经历"类的"时间区间"和"公司名称等属性"，也可以被复制。

## 模式介绍

### 解决方案

- 客户端只需调用 Clone 方法，就可以实现新简历的生成，并且可以再修改简历的细节；
- 工作经历类实现 Clone 方法；
- 在简历类中，引用"工作经历"对象：
  - 在实例化简历类时，同时实例化"工作经历"；
  - 在简历类中提供私有构造方法，Clone"工作经历"的数据。

### 代码实现

工作经验类：

```java
public class 工作经验 implements Cloneable {
    private String 工作日期;
    private String 公司名称;

    public String 获取工作日期() {
        return 工作日期;
    }

    public void 设置工作日期(String 工作日期) {
        this.工作日期 = 工作日期;
    }

    public String 获取公司名称() {
        return 公司名称;
    }

    public void 设置公司名称(String 公司名称) {
        this.公司名称 = 公司名称;
    }

    public Object 克隆() {
        try{
            return (Object)clone();
        }catch (CloneNotSupportedException ex) {
            ex.printStackTrace();
        }
        return null;
    }
}
```

简历类

```java
public class 简历 implements Cloneable {
    private String 姓名;
    private String 性别;
    private String 年龄;
    private 工作经验 工作;

    public 简历(String 姓名) {
        this.姓名 = 姓名;
        this.工作 = new 工作经验();
    }

    private 简历(工作经验 工作) {
        this.工作 = (工作经验)工作.克隆();
    }

    public void 设置个人信息(String 性别, String 年龄) {
        this.性别 = 性别;
        this.年龄 = 年龄;
    }

    public void 设置工作经验(String 工作日期, String 公司) {
        工作.设置工作日期(工作日期);
        工作.设置公司名称(公司);
    }

    public void 展示() {
        System.out.println(this.获取姓名() + " " + this.获取性别() + " " + this.获取年龄());
        System.out.println("Work experience: " + 工作.获取工作日期() + " " + 工作.获取公司名称());
    }

    public Object 克隆() {
        简历 对象 = new 简历(this.工作);
        对象.姓名 = this.姓名;
        对象.性别 = this.性别;
        对象.年龄 = this.年龄;
        return 对象;
    }

    public String 获取姓名() {
        return this.姓名;
    }
    public String 获取性别() {
        return this.性别;
    }
    public String 获取年龄() {
        return this.年龄;
    }
}
```

客户端调用的代码：

```java
public class 简历客户端 {
    public static void main(String[] args) {
        简历 a = new 简历("Big bird");
        a.设置个人信息("Female", "29");
        a.设置工作经验("1998-2000", "Datawhale");
        a.展示();
    }
}
```

执行结果：

```bash
Big bird Female 29
Work experience: 1998-2000 Datawhale
```

### 结构组成

原型模式其实就是从一个对象再创建另一个可定制的对象，并且不需知道任何创建细节。

![原型模式UML](img/prototype/PrototypeUML.png)

- Prototype：原型类，是一个抽象类，有 Clone 方法；
- ConcretePrototype：具体原型类，创建当前对象的浅表副本；
- Client：克隆 ConcretePrototype 的对象，就能得到新的实例。

## 模式评价

### 适用场景

> 实际项目中，原型模式很少单独出现。一般和工厂方法模式一起出现，通过 Clone 创建对象，然后由工厂方法提供给调用者。

- 直接创建对象的代价较大时，常采用原型模式，可提升性能；
- new 一个对象需要非常繁琐的数据准备或访问权限；
- 一个对象多个修改者的场景。

### 优点缺点

优点：

- 提高性能；
- 逃避构造函数的约束。

缺点：

- 需要对类的功能进行通盘考虑，对于已有的类不一定很容易。特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候；
- 必须实现 Cloneable 接口。

</div>
</div>
  
<div class="side-by-side-panel">
<div class="side-by-side-header">💡 解读</div>
<div class="side-by-side-content">

想象你是一名系统架构师，正在设计一个简历管理系统。用户需要创建多份不同时间点的简历，其中基本信息（姓名、性别）不变，只有工作经历和年龄会变化。如果每次创建新简历都重新实例化对象，会带来性能开销。

原型模式就是为了解决这个问题：通过克隆已有对象来创建新对象，避免重复初始化操作。

## 原型模式的核心思想

原型模式是一种创建型设计模式，它通过复制现有对象（原型）来创建新对象，而不是通过 new 操作符。这就像生物体的克隆技术，基于一个母本快速复制出相似的个体。

## 技术实现要点

### 1. 浅复制 vs 深复制

- **浅复制**：只复制对象本身和值类型字段，引用类型字段仍然指向原对象

  - 就像复印一张纸，纸本身复制了，但纸上写的电话号码还是指向同一个号码

- **深复制**：复制对象及其所有引用的对象
  - 不仅复印了纸，还为新纸创建了全新的电话号码

在简历例子中：

```java
// 浅复制问题示例
简历 resume1 = new 简历("张三");
resume1.设置工作经验("2020-2022", "A公司");

简历 resume2 = (简历)resume1.clone();
resume2.设置工作经验("2022-2023", "B公司");

// 浅复制会导致resume1的工作经历也被修改！
```

### 2. Java 中的实现机制

- 实现`Cloneable`接口（标记接口）
- 重写`clone()`方法
- 注意访问权限（`clone()`是 protected 方法）

### 3. 深复制的实现方式

简历例子中展示了如何实现深复制：

```java
// 在简历类中
private 简历(工作经验 工作) {
    this.工作 = (工作经验)工作.克隆(); // 关键点：克隆工作经验对象
}

public Object 克隆() {
    简历 对象 = new 简历(this.工作); // 使用私有构造函数进行深复制
    对象.姓名 = this.姓名;
    对象.性别 = this.性别;
    对象.年龄 = this.年龄;
    return 对象;
}
```

## 架构师视角的思考

### 适用场景

1. **对象创建成本高**：当对象初始化需要大量资源（如数据库连接、复杂计算）
2. **需要隔离变化**：当需要保护原始对象不被修改时
3. **组合对象创建**：当对象包含多层嵌套引用时

### 实际应用案例

1. **游戏开发**：快速克隆游戏角色、道具
2. **文档处理**：模板文档的复制
3. **缓存系统**：从缓存原型快速创建对象

### 性能考量

原型模式通过避免重复初始化提高了性能，但需要注意：

- 深复制可能比浅复制消耗更多资源
- 对于简单对象，直接 new 可能更高效

### 与其他模式的结合

- **与工厂模式结合**：原型工厂可以管理一组原型对象
- **与组合模式结合**：复制复杂对象结构
- **与备忘录模式结合**：实现对象状态的保存和恢复

## 面试常见问题

1. **原型模式和 new 操作的区别？**

   - new 需要完整的初始化过程
   - 原型模式基于已有对象快速复制

2. **如何选择浅复制还是深复制？**

   - 取决于业务需求
   - 引用对象是否需要独立修改

3. **原型模式的线程安全问题？**
   - 克隆过程本身是线程安全的
   - 但原型对象如果是可变共享状态需要同步控制

## 总结

原型模式是系统架构中优化对象创建的重要手段。作为架构师，你需要：

1. 识别对象复用的场景
2. 合理选择浅/深复制策略
3. 考虑原型管理的扩展性
4. 权衡性能与资源消耗

理解原型模式不仅能帮助你在软考中得分，更能提升你在实际系统设计中的对象管理能力。

</div>
</div>
</div>
