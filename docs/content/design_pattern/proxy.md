# 代理模式

## 1 问题引入

### 1.1 问题描述

&emsp;&emsp;小菜听了这样一个故事：卓贾易委托戴励追求娇娇，让戴励给娇娇送各种礼物，最后为戴励做了嫁衣，戴励和娇娇在一起了。

&emsp;&emsp;上述代理的故事可以用C++、Java、python、C#等任意一种编程语言实现。


### 1.2 问题分析

&emsp;&emsp;这一问题中有三个类型的角色，追求者，代理和被追求者。他们三者间的关系满足，追求者委托代理，通知代理给被追求者送礼物，而被追求者不知道追求者的存在。

### 1.3 解决方案

&emsp;&emsp;此时可以考虑使用`代理模式`来解决问题。
1. 创建送礼物的抽象类`IGiveGift`，定义追求者和代理的共用接口：    
    * 送玩具方法`GiveDolls()`;
    * 送花方法`GiveFlowers()`;
    * 送巧克力方法`GiveChocolate()`。
2. 创建追求者`Pursuit`，定义需要代理的真正实体，继承于抽象类`IGiveGift`:    
    * 覆写类初始化方法，记录被追求者姓名；
    * 覆写送玩具、送花、送巧克力方法，具体送礼操作。
3. 创建代理`Proxy`，保存追求者实体的一个引用，使得代理可以访问实体，继承于抽象类`IGiveGift`，实现对实体的替代：    
    * 覆写类初始化方法，初始化的同时初始化一个追求者`Pursuit`对象；
    * 覆写送玩具、送花、送巧克力方法，在每一个送礼方法下调用追求者`Pursuit`的具体送礼操作。

### 1.4 代码实现

* C++语言实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/cpp/proxy/)
* Java语言实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/java/proxy/)
* python语言实现：[链接](https://github.com/datawhalechina/sweetalk-design-pattern/tree/main/src/design_patterns/python/proxy/Proxy.py)
* C#语言实现见原书第二版。

## 2 模式介绍

### 2.1 定义

&emsp;&emsp;`代理模式（Proxy Pattern）`是指实现一个类代表另一个类的功能，为其他对象提供一种代理以控制对这个对象的访问。

### 2.2 结构

&emsp;&emsp;结构示意图如下

![装饰模式UML](img/proxy/proxyUML.png)

&emsp;&emsp;以上述问题为例，结构如下

![案例UML](img/proxy/exampleUML.png)

## 3 适用场景

> 不方便直接访问对象时，为不宜直接访问的对象提供一个访问层。    
> 使用代理模式的方式分为以下几种：    
> * 本地执行远程服务（远程代理）：适用于服务对象位于远程服务器上的情形，可以为一个对象在不同的地址空间提供局部代表。
> * 延迟初始化（虚拟代理）：如果你有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式。
> * 访问控制（保护代理/安全代理）：如果只希望特定客户端使用服务对象，对象可以是操作系统中的重要部分，而客户端则是各种已启动程序，可使用代理模式。
> * 记录日志请求（日志记录代理）：适用于需要保存对于服务对象的请求历史记录时。
> * 缓存请求结果（缓存代理）：适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是返回结果体积非常大时。
> * 智能指引：调用真实对象时，代理处理另外一些事，可在没有客户端使用某个重量级对象时，立刻销毁该对象。

&emsp;&emsp;例如：
* 信用卡是银行账户的代理，而银行账户则是一大捆现金的代理。它们都可以实现相同的支付功能。
* windows里的快捷方式。
* 客户端对数据库的查询有时要消耗大量系统资源，常在有需要时才创建（延迟初始化），这会带来代码的大量重复。可以创建代理，让代理伪装成数据库对象，在客户端或实际数据库对象不知情的情况下处理延迟初始化和缓存查询结果的工作。



## 4 评价

### 4.1 优点

* 引入代理后，职责清晰；
* 引入代理后，可扩展多种用途，如：    
    * 远程代理可以隐藏一个对象存在于不同地址空间的事实。
    * 虚拟代理可以存放实例化时间很长的真实对象。
* 符合“开放封闭原则”，无需对服务器或客户端进行修改就创建新的代理。

### 4.2 缺点

* 代码可能变得复杂，因为需要新建许多类；
* 服务响应可能会延迟。


## 参考资料
1. 《深入设计模式》
