# 状态模式

<div class="side-by-side-container">
<div class="side-by-side-panel">
<div class="side-by-side-header">📖 原文</div>
<div class="side-by-side-content">

## 模式引入

### 问题描述

假设我们要描述一名员工一天不同时间的工作状态，正常来看是比较简单的，直接从早上上班开始，根据一些时间变化切换到其他状态。但假设我们切换到一个状态后又可能需要根据另外的条件再次切换，比如本来在写代码，到晚上了还没写完，继续写。好不容易写完了，需要切换到下班状态；或者没写完，直到睡着还没写完。这需要各种条件判断（每个状态都要判断是否满足跳到其他状态），不光是写起来复杂，新增状态和更新状态更是会变得异常麻烦。

此时，很自然我们就会想要将一个个状态独立出来，为每个状态设置所有需要的切换条件，在状态发生变化时改变对应的行为。这样我们只需要关心状态从 A 转换到 B，而不用管各种判断逻辑。

### 模式定义

当控制一个对象状态转换的条件表达式过于复杂时，把状态的判断逻辑转移到表示不同状态的一系列类中，可以简化复杂的判断逻辑。

状态模式允许一个对象在内部状态改变时改变它的行为，这个对象看起来好像改变了类。

状态模式将不同状态的行为分割开，将与特定状态相关的行为局部化（放入一个对象），通过新的类很容易新增状态。状态模式通过把各种状态的转移逻辑分布到 State 的子类之间，减少相互依赖，消除庞大的条件分支判断。

### 问题分析

考虑用状态模式来实现上面的问题，具体来说，我们可以将不同时间段、休息、睡觉等都设置为一个个状态，每个状态内部有自己的转换判断，比如上午可以切换到下午，但不能直接切换到下班。这样每种状态有自己的判断逻辑，行为和状态绑定，外部只需直接切换到想要的状态即可。

## 模式实现

### 解决方案

主要是定义一系列状态以及在状态内部实现该状态的转移逻辑。

- 抽象状态 `State`，定义一个抽象方法，如 `writeProgram`。
- 实现不同的具体状态类：`ForenoonState`、`NoonState`、`AfternoonState`等，并重写抽象方法。
- 实现一个上下文类：`Work` 用来管理当前状态。

下面是一些注意事项：

- 将状态的转换放到具体的状态类内部。
- 通过上下文直接或通过参数改变状态，而不同的状态对应不同的行为。

### 代码实现

`状态` 类：

```java
public abstract class 状态 {
    public abstract void 写程序(工作 w);
}
```

`具体状态` 类：

```java
public class 上午状态 extends 状态 {
    @Override
    public void 写程序(工作 w) {
        if(w.获取小时() < 12) {
            System.out.println("当前时间：" + w.获取小时() + "点 上午工作，精神百倍");
        }else {
            w.设置状态(new 中午状态());
            w.写程序();
        }
    }
}

public class 中午状态 extends 状态 {
    @Override
    public void 写程序(工作 w) {
        if(w.获取小时() < 13) {
            System.out.println("当前时间：" + w.获取小时() + "点 饿了，午饭；犯困，午休");
        }else {
            w.设置状态(new 下午状态());
            w.写程序();
        }
    }
}

public class 下午状态 extends 状态 {
    @Override
    public void 写程序(工作 w) {
        if(w.获取小时() < 17){
            System.out.println("当前时间 " + w.获取小时() +  "点 下午状态还不错，继续努力");
        }else {
            w.设置状态(new 晚上状态());
            w.写程序();
        }
    }
}

public class 休息状态 extends 状态 {
    @Override
    public void 写程序(工作 w) {
        System.out.println("当前时间：" + w.获取小时() + "点 下班回家了");
    }
}

public class 睡觉状态 extends 状态 {
    @Override
    public void 写程序(工作 w) {
        System.out.println("当前时间：" + w.获取小时() + "点 不行了，睡着了。");
    }
}

public class 晚上状态 extends 状态 {
    @Override
    public void 写程序(工作 w) {
         if(w.是否完成()) {
             w.设置状态(new 休息状态());
             w.写程序();
         }else {
             if(w.获取小时() < 21) {
                 System.out.println("当前时间：" + w.获取小时() + "点 加班哦，疲累之极");
             }else {
                 w.设置状态(new 睡觉状态());
                 w.写程序();
             }
         }
    }
}


```

`上下文` 类：

```java
public class 工作 {
    private 状态 当前状态;

    public 工作() {
        当前状态 = new 上午状态();
    }

    private int 小时;
    public int 获取小时() {
        return 小时;
    }
    public void 设置小时(int 小时) {
        this.小时 = 小时;
    }

    private boolean 完成 = false;
    public boolean 是否完成() {
        return 完成;
    }
    public void 设置完成(boolean 完成) {
        this.完成 = 完成;
    }

    public void 设置状态(状态 s) {
        当前状态 = s;
    }

    public void 写程序() {
        当前状态.写程序(this);
    }
}
```

`主类` 方法：

```java
public class 主类 {
    public static void main(String[] args) {
        工作 紧急项目 = new 工作();
        紧急项目.设置小时(9);
        紧急项目.写程序();

        紧急项目.设置小时(10);
        紧急项目.写程序();

        紧急项目.设置小时(12);
        紧急项目.写程序();

        紧急项目.设置小时(13);
        紧急项目.写程序();

        紧急项目.设置小时(14);
        紧急项目.写程序();

        紧急项目.设置小时(17);
        紧急项目.写程序();

        紧急项目.设置完成(false);
        紧急项目.写程序();

        紧急项目.设置小时(19);
        紧急项目.写程序();

        紧急项目.设置小时(22);
        紧急项目.写程序();
    }
}
```

执行结果：

```bash
当前时间：9点 上午工作，精神百倍
当前时间：10点 上午工作，精神百倍
当前时间：12点 饿了，午饭；犯困，午休
当前时间 13点 下午状态还不错，继续努力
当前时间 14点 下午状态还不错，继续努力
当前时间：17点 加班哦，疲累之极
当前时间：17点 加班哦，疲累之极
当前时间：19点 加班哦，疲累之极
当前时间：22点 不行了，睡着了。
```

### 结构组成

![](img/state/state.jpeg)

- 状态：抽象状态类，定义一个接口用来封装与 上下文 的一个特定状态相关的行为。
- 具体状态 类：具体状态类，每个子类实现一个与 上下文 一个状态相关的行为。
- 上下文 类：维护一个 具体状态 子类的实例，定义当前状态。

## 模式评价

### 适用场景

- 当一个对象的行为取决于它的状态，并且必须在运行时根据状态改变其行为时。比如上面例子中，可以根据设置任务完成状态改变具体行为。
- 某业务有多个状态，且状态变化依赖大量分支判断时。上面的例子使用状态模式后将状态的逻辑判断转移到具体状态内，避免了多条分支判断。

如果状态的判断很简单，就不需要使用状态模式了。

### 实际应用

实际中的例子：多个状态与行为变化。

- 有限状态机。
- TCP 连接协议。主要是连接状态的管理。
- 其他涉及一系列状态变化的应用。

### 优点缺点

状态模式的优点包括：

- 状态即行为，通过状态的改变引起行为的变化，消除了条件逻辑，代码更简单清晰。
- 与特定状态相关的代码都放在一起，提高了聚合性。
- 添加一个状态非常容易，提高了扩展性。

状态模式的缺点包括：

- 可能会创建太多功能较为单一的类。当状态粒度太小时，这种情况尤其明显。
- 新的行为可能涉及大量改动。因为该行为可能涉及到多个类，此时需要更新所有涉及到的类，将新的行为逻辑加入。
- 状态少或很少改变时有点小题大做，此时不应使用状态模式。

</div>
</div>
  
<div class="side-by-side-panel">
<div class="side-by-side-header">💡 解读</div>
<div class="side-by-side-content">

好的，我来帮你从系统架构设计师的角度，用通俗易懂的方式理解状态模式。

### 1. 生活化理解状态模式

想象你是一个程序员，一天的工作状态是这样的：

- 上午（9-12 点）：精神饱满写代码
- 中午（12-13 点）：吃饭午休
- 下午（13-17 点）：继续写代码但效率略低
- 晚上（17-21 点）：加班（如果任务没完成）
- 深夜（21 点后）：扛不住睡着了

如果用传统 if-else 实现：

```java
if(时间<12){上午状态}
else if(时间<13){中午状态}
else if(时间<17){下午状态}
else if(任务完成){下班}
else if(时间<21){加班}
else{睡觉}
```

每新增一个状态（比如"喝咖啡状态"），就要修改整个判断逻辑，违反开闭原则。

### 2. 状态模式如何解决

就像把不同部门的工作拆分到不同办公室：

- 每个状态是一个独立类（上午办公室/下午办公室等）
- 每个办公室自己决定什么时候该转移到下一个办公室
- 你（Context）只需要告诉当前办公室"现在该做什么"

### 3. 架构师视角的关键点

**(1) 状态与行为的绑定**

- 每个状态类包含：① 自身行为 ② 转移条件
- 例如`晚上状态`会判断：任务完成 → 切到休息状态；超过 21 点 → 切到睡觉状态

**(2) 消除条件分支**

- 传统方式：一个包含所有状态判断的"上帝类"
- 状态模式：判断逻辑分散到各个状态类中

**(3) 开闭原则**

- 新增状态只需添加新类（如"开会状态"）
- 不需要修改现有状态类（除非涉及状态转移关系变更）

### 4. 技术实现要点

```java
// 抽象状态（相当于所有办公室的通用规范）
abstract class State {
    abstract void handle(WorkContext context);
}

// 具体状态（具体办公室）
class MorningState extends State {
    void handle(WorkContext ctx) {
        if(ctx.time < 12) {
            System.out.println("精神百倍写代码");
        } else {
            ctx.setState(new NoonState()); // 自动转移状态
            ctx.handle(); // 继续处理
        }
    }
}

// 上下文（相当于你本人）
class WorkContext {
    private State currentState;
    private int time;

    void handle() {
        currentState.handle(this); // 委托给当前状态处理
    }
}
```

### 5. 实际架构案例

**(1) TCP 连接状态机**

- 状态：SYN_SENT、ESTABLISHED、FIN_WAIT 等
- 每个状态处理报文并决定是否跳转状态

**(2) 订单状态流转**

- 状态：待支付、已支付、已发货、已完成
- 每个状态决定能执行的操作（支付、发货、确认收货）

### 6. 考试注意要点

- **优点**：
  - 符合单一职责原则（每个状态一个类）
  - 符合开闭原则（新增状态不修改现有代码）
- **缺点**：

  - 状态过多会导致类爆炸（小项目慎用）
  - 状态转移不清晰（如果转移逻辑分散在各状态中）

- **考题常见形式**：
  - 给一个多状态场景（如电梯、工作流）
  - 要求对比状态模式与策略模式的区别
  - 判断是否违反开闭原则/单一职责原则

### 7. 记忆口诀

> "状态分家各管各，
> 行为转移自己说，
> 新增状态不修改，
> 条件分支不再多"

希望这个解释能帮你建立直观理解！备考时可以多画状态转换图，思考哪些系统适合用这个模式（有明显状态划分且行为随状态变化的场景）。

</div>
</div>
</div>
