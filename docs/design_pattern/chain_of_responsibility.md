# 职责链模式

<AppTabs>

<AppTab label="📖 原文">


## 模式引入

### 问题描述

加薪、请假申请等需要层层审批的场景。比如向经理提加薪申请，经理没权利然后向总监上报，总监没权限然后向总经理汇报等。

### **模式定义**

职责链模式核心是解决服务中先后执行处理关系，从而降低请求发送者和接受者之间的耦合关系。类似于击鼓传花。

### 问题分析

如果将管理者创建成为一个类，那么该类会具有太多的责任，比如经理、总监以及总经理的审批和上报功能，就违背了单一职责原则。而且以后的需求可能会增加新的管理类别，比如项目经理、部门经理、人事总监等，那么就势必会修改管理者类以完成扩展，就违背了开放封闭原则。

## 模式实现

### 解决方案

将公司管理者的类别变成管理者的子类，可以通过多态性来化解分支带来的僵化。然后通过不同管理者之间建立管理关系实现请求的传递，使得请求的发送者和接收者解耦，可以让各服务模块更加清晰。处理者负责处理请求，客户只需要将请求发送到职责链，无需关心具体的处理细节。

处理者（处理者）：用于定义一个处理请示的接口。

具体处理者（具体处理者）：处理它所负责的请求，可访问它的后继者，如果能够处理就处理，否则就将请求转发给它的后继者。

### 代码实现

`请求` 类：

```java
public class 请求 {
    private String 请求类型;
    private String 请求内容;
    private int 数量;

    public String 获取请求类型() {
        return 请求类型;
    }

    public void 设置请求类型(String 请求类型) {
        this.请求类型 = 请求类型;
    }

    public String 获取请求内容() {
        return 请求内容;
    }

    public void 设置请求内容(String 请求内容) {
        this.请求内容 = 请求内容;
    }

    public int 获取数量() {
        return 数量;
    }

    public void 设置数量(int 数量) {
        this.数量 = 数量;
    }
}
```

`管理者` 类：

```java
public abstract class 管理者 {
    protected String 姓名;
    protected 管理者 上级;

    protected 管理者(String 姓名) {
        this.姓名 = 姓名;
    }

    public void 设置上级(管理者 上级) {
        this.上级 = 上级;
    }

    public abstract void 处理请求(请求 请求对象);
}
```

`具体管理者` 类：

```java
public class 总经理 extends 管理者 {
    protected 总经理(String 姓名) {
        super(姓名);
    }

    @Override
    public void 处理请求(请求 请求对象) {
        if(请求对象.获取请求类型() == "请假"){
            System.out.println(姓名 + "：" + 请求对象.获取请求内容() + " 数量" + 请求对象.获取数量() + " 被批准" );
        }else if(请求对象.获取请求类型() == "加薪" && 请求对象.获取数量() <= 500) {
            System.out.println(姓名 + "：" + 请求对象.获取请求内容() + " 数量" + 请求对象.获取数量() + " 被批准" );
        }else {
            System.out.println(姓名 + "：" + 请求对象.获取请求内容() + " 数量" + 请求对象.获取数量() + " 再说吧" );
        }
    }
}

public class 总监 extends 管理者 {
    protected 总监(String 姓名) {
        super(姓名);
    }

    @Override
    public void 处理请求(请求 请求对象) {
        if(请求对象.获取请求类型() == "请假" && 请求对象.获取数量() <= 5) {
            System.out.println(姓名 + "：" + 请求对象.获取请求内容() + " 数量" + 请求对象.获取数量() + " 被批准" );
        }else {
            if(上级 != null) {
                上级.处理请求(请求对象);
            }
        }
    }
}

public class 普通经理 extends 管理者 {
    protected 普通经理(String 姓名) {
        super(姓名);
    }

    @Override
    public void 处理请求(请求 请求对象) {
        if(请求对象.获取请求类型() == "请假" && 请求对象.获取数量() <= 2) {
            System.out.println(姓名 + "：" + 请求对象.获取请求内容() + " 数量" + 请求对象.获取数量() + " 被批准" );
        }else {
            if(上级 != null) {
                上级.处理请求(请求对象);
            }
        }
    }
}
```

`主类` 方法：

```java
public class 主类 {
    public static void main(String[] args) {
        普通经理 普通经理 = new 普通经理("金利");
        总监 总监 = new 总监("宗剑");
        总经理 总经理 = new 总经理("钟精励");
        普通经理.设置上级(总监);
        总监.设置上级(总经理);

        请求 请求对象 = new 请求();
        请求对象.设置请求类型("请假");
        请求对象.设置请求内容("小菜请假");
        请求对象.设置数量(1);
        普通经理.处理请求(请求对象);

        请求 请求对象2 = new 请求();
        请求对象2.设置请求类型("请假");
        请求对象2.设置请求内容("小菜请假");
        请求对象2.设置数量(4);
        普通经理.处理请求(请求对象2);

        请求 请求对象3 = new 请求();
        请求对象3.设置请求类型("加薪");
        请求对象3.设置请求内容("小菜请求加薪");
        请求对象3.设置数量(500);
        普通经理.处理请求(请求对象3);

        请求 请求对象4 = new 请求();
        请求对象4.设置请求类型("加薪");
        请求对象4.设置请求内容("小菜请求加薪");
        请求对象4.设置数量(1000);
        普通经理.处理请求(请求对象4);
    }
}
```

执行结果：

```bash
金利：小菜请假 数量1 被批准
宗剑：小菜请假 数量4 被批准
钟精励：小菜请求加薪 数量500 被批准
钟精励：小菜请求加薪 数量1000 再说吧
```

### 结构组成

![image-20221017164911912](img/chain_of_responsibility/chain_of_responsibility.jpg)

## 模式评价

### 适用场景

一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。

### 实际应用

- Netty 中 Pipeline 与 ChannelHandler 通过责任链来组织代码逻辑。
- Tomcat 中 Servlet 过滤器使用了责任链模式。
- Spring 中切面编程和安全机制都使用了责任链模式。

### 优点缺点

模式优点：

- 能够简化对象的相互连接，接收者和发送者都没有对方的明确信息，且链中的对象也不知道链的结构。
- 避免了请求的发送者和接受者之间的耦合关系。
- 能够随时修改请求的结构，增强了给对象指派职责的灵活性

模式缺点：

- 请求可能到了链的末端都得不到处理，或者因为没有正确配置得不到处理。
- 较长的责任链可能会影响到系统的性能。
</AppTab>
<AppTab label="💡 解读">


想象你在公司请假：

- 你先找小组长批（他能批 1 天）
- 小组长批不了就转给部门经理（能批 3 天）
- 部门经理批不了再转给总监（能批 7 天）
- 最后到 CEO（能批所有）

这就是职责链：请求像击鼓传花一样，沿着预设的链条传递，直到有人能处理为止。

### 2. 架构师视角的核心价值

**解耦**：发送者（员工）不需要知道具体谁来处理，只需要把请求丢给第一个节点。

**动态调整**：可以随时调整链条顺序（比如新增"项目经理"层级），而不用修改原有代码。

### 3. 技术实现关键点（结合代码）

```java
// 抽象处理者（核心）
public abstract class 管理者 {
    protected 管理者 上级; // 关键：持有下一个节点的引用

    public void 处理请求(请求 请求对象) {
        if(自己能处理(请求对象)){
            处理逻辑();
        }else if(上级 != null){
            上级.处理请求(请求对象); // 递归调用
        }else{
            拒绝逻辑();
        }
    }
}
```

### 4. 架构设计中的典型应用

**案例 1：审批系统**

- 每个审批节点是独立微服务
- 通过消息队列（如 Kafka）实现链式传递
- 审批规则可配置化（无需改代码）

**案例 2：Web 过滤器链**

```java
// Tomcat的FilterChain实现
public void doFilter(request, response) {
    if(index < filters.length){
        filters[index++].doFilter(request, response, this);
    }else{
        servlet.service(request, response);
    }
}
```

### 5. 系统架构中的实践建议

**性能优化**：

- 设置最大传递深度（防止无限循环）
- 对高频链条可采用备忘录模式缓存结果

**异常处理**：

- 建议实现"终结节点"确保必有响应
- 使用观察者模式监控链条状态

### 6. 考试常见考点

**设计原则体现**：

- 单一职责：每个处理者只处理自己权限内的事
- 开闭原则：新增处理者无需修改已有代码

**对比其他模式**：

- 与状态模式区别：状态模式是处理对象自身状态变化，职责链是多个对象协作
- 与装饰器模式区别：装饰器是叠加功能，职责链是选择执行

### 7. 实际架构案例

**金融风控系统**：

```
请求 -> 反欺诈检测 -> 信用评分 -> 黑名单校验 -> 人工复核
```

每个环节都是独立处理者，可以：

1. 动态调整校验顺序
2. 快速插入新的风控节点
3. 单独升级某个校验模块

### 8. 可能坑点提醒

1. **循环引用**：A 的上级是 B，B 的上级是 A → 需校验链条合法性
2. **性能陷阱**：链条过长时建议改用"责任树"结构
3. **日志缺失**：必须记录完整的传递路径，方便问题追踪

### 9. 扩展思考题

如果需求变成："某个审批需要同时经过财务总监和技术总监审批"（并联审批），该如何改造职责链模式？

提示：可以考虑组合模式 + 职责链的混合模式，建立多叉树型的处理结构。

希望这个解读能帮助你在备考时既理解本质，又能联系实际架构设计。备考时可以多思考：如果让你设计一个 OA 审批系统，如何用这个模式支持未来可能新增的"临时委员会审批"等特殊环节？

</AppTab>
</AppTabs>