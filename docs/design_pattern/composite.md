# 组合模式

<AppTabs>

<AppTab label="📖 原文">


## 模式引入

### 问题描述

假设我们要给一家公司做一个 OA 系统，公司总部在北京，全国几个大城市都有子公司，其他一些省会城市是办事处，有些城市还设置了大区。总部有职能部门，各个子公司也有自己的职能部门。这是一个明显的树状结构，最简单的想法是针对不同类型（如公司或部门）组织创建不同的对象，组织之间的交互在其内部实现。但是这样有不少问题，比如无法体现公司的组织结构，交互的实现复杂混乱，新增类型时工作量巨大等等。而且对用户来说，这不同类型其实是类似的——都是组织。

### 模式定义

像刚刚这种具有层级结构，且组成对象具有一致性的情况，就适合使用组合模式。

组合模式（Composite）是将对象组合成树形结构以表示 “部分-整体” 的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

### 问题分析

使用组合模式解决上面的问题，总部是根节点，下面有各个职能部门以及与其平行的子公司，每个子公司下面又有自己的职能部门。

## 模式实现

### 解决方案

- 首先需要一个抽象类：`公司`，可以是一个公司或部门。包括 `添加`、`移除`、`显示` 等方法。
- 然后分别实现树枝节点具体公司类：`具体公司` 和树叶节点：`人力资源部门` 和 `财务部门`，并重写抽象方法。

### 代码实现

`组件` 类：

```java
public abstract class 公司 {
    protected String 名称;

    public 公司(String 名称) {
        this.名称 = 名称;
    }

    public abstract void 添加(公司 c);
    public abstract void 移除(公司 c);
    public abstract void 显示(int 深度);
    public abstract void 履行职责();
}
```

`组合` 类：

```java
public class 具体公司 extends 公司 {

    private List<公司> 子节点 = new ArrayList<>();

    public 具体公司(String 名称) {
        super(名称);
    }

    @Override
    public void 添加(公司 c) {
        子节点.add(c);
    }

    @Override
    public void 移除(公司 c) {
        子节点.remove(c);
    }

    @Override
    public void 显示(int 深度) {
        for(int i = 0; i < 深度; i++) {
            System.out.print("-");
        }
        System.out.println(this.名称);

        for(公司 组件 : 子节点) {
            组件.显示(深度 + 2);
        }
    }

    @Override
    public void 履行职责() {
        for(公司 组件 : 子节点) {
            组件.履行职责();
        }
    }
}
```

`叶子` 类：

```java
public class 人力资源部门 extends 公司 {

    public 人力资源部门(String 名称) {
        super(名称);
    }

    @Override
    public void 添加(公司 c) {}

    @Override
    public void 移除(公司 c) {}

    @Override
    public void 显示(int 深度) {
        for(int i = 0; i < 深度; i++) {
            System.out.print("-");
        }
        System.out.println(this.名称);
    }

    @Override
    public void 履行职责() {
        System.out.println(this.名称 + " 员工招聘培训管理");
    }
}

public class 财务部门 extends 公司 {
    public 财务部门(String 名称) {
        super(名称);
    }

    @Override
    public void 添加(公司 c) {}

    @Override
    public void 移除(公司 c) {}

    @Override
    public void 显示(int 深度) {
        for(int i = 0; i < 深度; i++) {
            System.out.print("-");
        }
        System.out.println(this.名称);
    }

    @Override
    public void 履行职责() {
        System.out.println(this.名称 + " 公司财务收支管理");
    }
}
```

`主类` 方法：

```java
public class 主类 {
    public static void main(String[] args) {
        具体公司 根节点 = new 具体公司("北京总公司");
        根节点.添加(new 人力资源部门("总公司人力资源部"));
        根节点.添加(new 财务部门("总公司财务部"));

        具体公司 分公司 = new 具体公司("上海华东分公司");
        分公司.添加(new 人力资源部门("华东分公司人力资源部"));
        分公司.添加(new 财务部门("华东分公司财务部"));
        根节点.添加(分公司);

        具体公司 办事处1 = new 具体公司("南京办事处");
        办事处1.添加(new 人力资源部门("南京办事处人力资源部"));
        办事处1.添加(new 财务部门("南京办事处财务部"));
        根节点.添加(办事处1);

        具体公司 办事处2 = new 具体公司("杭州办事处");
        办事处2.添加(new 人力资源部门("杭州办事处人力资源部"));
        办事处2.添加(new 财务部门("杭州办事处财务部"));
        根节点.添加(办事处2);

        System.out.println("\n结构图：");
        根节点.显示(1);

        System.out.println("\n职责：");
        根节点.履行职责();
  }
}
```

执行结果：

```bash
结构图：
-北京总公司
---总公司人力资源部
---总公司财务部
---上海华东分公司
-----华东分公司人力资源部
-----华东分公司财务部
---南京办事处
-----南京办事处人力资源部
-----南京办事处财务部
---杭州办事处
-----杭州办事处人力资源部
-----杭州办事处财务部

职责：
总公司人力资源部 员工招聘培训管理
总公司财务部 公司财务收支管理
华东分公司人力资源部 员工招聘培训管理
华东分公司财务部 公司财务收支管理
南京办事处人力资源部 员工招聘培训管理
南京办事处财务部 公司财务收支管理
杭州办事处人力资源部 员工招聘培训管理
杭州办事处财务部 公司财务收支管理
```

### 结构组成

![](img/composite/composite.jpg)

- 组件（对象接口）：主要实现所有类共有接口的默认行为，声明一个接口，用于访问和管理 组件 的子部件。
- 组合（枝节点）：定义枝节点行为，用于存储子部件，在 组件 接口中实现与子部件有关的操作，比如增加（添加）和删除（移除）。
- 叶子（叶节点）：表示叶节点对象，叶节点没有子节点。

## 模式评价

### 适用场景

- 体现部分与整体层次的结构时。比如例子中具有层级结构的组织结构。
- 希望用户忽略组合对象与单个对象的不同，统一使用组合结构中的所有对象时。

### 实际应用

- 公司管理系统。如例子所示。
- 文件系统。文件系统是一个典型的树状层级结构。
- 编译器。编译器会将代码最终解析为一棵语法树。

### 优点缺点

组合模式优点包括：

- 让用户可以一致地使用组合结构和对象。比如例子中的子公司和部门。
- 组合对象可以自由增删组件，灵活组合不同对象。

组合模式缺点包括：

- 层级太深时结构会变得庞杂。
</AppTab>
<AppTab label="💡 解读">

想象你是一家集团公司的 IT 架构师，要设计 OA 系统来管理整个集团的组织架构。集团有总部、分公司、办事处、各部门，就像一棵大树：

- 树根：北京总部
- 树枝：上海分公司、南京办事处
- 树叶：人力资源部、财务部

#### 传统做法的问题（不用组合模式）

如果给每种组织（总部/分公司/部门）都单独设计类：

- 总部类、分公司类、人力资源部类...
- 当要显示整个组织架构时，需要写复杂的嵌套循环
- 新增一个"研发中心"类型时，所有相关代码都要修改
- 处理跨层级协作（如全公司发通知）非常麻烦

#### 组合模式的聪明做法

组合模式用"俄罗斯套娃"的思路：

1. 定义一个统一的"组织"接口（公司抽象类）
   - 包含通用方法：添加、移除、显示、执行职责
2. 两种具体实现：
   - **树枝节点**（如分公司）：可以包含其他节点
   - **叶子节点**（如部门）：不能再包含其他节点

就像文件夹（树枝）可以包含子文件夹或文件（叶子），但文件不能再包含其他东西。

### 技术实现要点（考试重点）

1. **组件抽象类**（公司）：

   ```java
   public abstract class 公司 {
       public abstract void 显示(int 深度); // 关键：统一的接口
       //...其他公共方法
   }
   ```

2. **组合节点**（具体公司）：

   ```java
   public class 具体公司 extends 公司 {
       private List<公司> 子节点 = new ArrayList<>(); // 关键：持有子节点集合

       public void 显示(int 深度) {
           // 显示自己
           for(公司 子节点 : 子节点){ // 递归调用子节点
               子节点.显示(深度+1);
           }
       }
   }
   ```

3. **叶子节点**（部门）：
   ```java
   public class 人力资源部门 extends 公司 {
       public void 显示(int 深度) {
           // 只显示自己，没有子节点
       }
   }
   ```

### 架构师考试易考点

1. **透明式 vs 安全式**：

   - 透明式（本例）：在抽象类中声明所有方法（包括 add/remove）
     - 优点：客户端无需区分节点类型
     - 缺点：叶子节点需要实现不需要的方法（空实现）
   - 安全式：只在组合节点中定义 add/remove
     - 优点：避免叶子节点冗余方法
     - 缺点：客户端需要做类型判断

2. **递归组合**：

   - 组合模式的核心是递归结构
   - 显示/执行职责时自动遍历整个树形结构

3. **使用场景判断**：
   - 适合：具有明确层级关系的系统（文件系统、组织架构、UI 组件）
   - 不适合：没有层次结构的平铺数据

### 实际应用案例

1. **文件系统**：

   - 组件：FileSystemComponent
   - 组合：Directory（可以包含子目录或文件）
   - 叶子：File

2. **GUI 组件**：
   - 组件：UIComponent
   - 组合：Panel（可以包含按钮、文本框等）
   - 叶子：Button

### 考试答题技巧

当题目出现以下关键词时考虑组合模式：

- "树形结构"、"部分-整体"
- "统一处理不同层级的对象"
- "需要动态添加/删除组件"

示例考题：
"某电商平台需要设计商品分类系统，支持多级分类（如家电 → 大家电 → 空调），且每个分类下可以有子分类或具体商品。请说明适合的设计模式及其实现方式。"

参考答案：
采用组合模式：

1. 抽象组件：ProductCategory（定义 add/remove/display）
2. 组合节点：Category（包含子分类集合）
3. 叶子节点：Product
4. 客户端可以统一处理任意层级节点

这样设计后，无论是处理一级分类"家电"还是三级分类"空调"，都可以通过相同的接口操作，且支持无限级分类扩展。

</AppTab>
</AppTabs>