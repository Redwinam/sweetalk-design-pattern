# 享元模式

<AppTabs>

<AppTab label="📖 原文">


## 问题引入

### 问题描述

菜鸟的朋友们都希望提供定制的网站，有的希望是新闻发布形式的、有的希望是博客形式的、有的希望是产品图片加说明形式的，但是都希望费用上能大大降低。如果每个网站都独立租用空间费用上基本不能减低，而且维护众多网站的代码需要投入很大的时间和精力。

### **模式定义**

享元模式，运用共享技术有效地支持大量细粒度的对象。

### 问题分析

网站系统的功能相似度很高，如果独立开发，对于出现 bug 或者新的需求变动会造成极高的维护量。

## 模式介绍

### 解决方案

通过享元模式可以避免大量非常相似类的开销，实现资源的共享。

Flyweight(享元的抽象类)：是所有具体享元类的超类或接口，通过该接口，可以接受并作用于外部状态。

ConcreteFlweight(具体享元类)：继承并扩展抽象类的方法，并为内部状态增加存储空间。

UnsharedConcreteFlyweight(非共享享元子类)：不需要共享的享元子类。

FlyweightFactory(享元工厂)：用来创建并管理享元对象，确保合理的共享资源。

### 代码实现

```java
public abstract class 网站 {
    public abstract void 使用(用户 用户对象);
}

public class 具体网站 extends 网站 {
    private String 名称;
    public 具体网站(String 名称) {
        this.名称 = 名称;
    }

    @Override
    public void 使用(用户 用户对象) {
        System.out.println("网站分类："+ 名称 + " 用户：" + 用户对象.获取姓名());
    }
}

public class 网站工厂 {
    private Map<String,网站> 享元池 = new HashMap<>();

    public 网站 获取网站分类(String 分类键) {
        if(!享元池.containsKey(分类键)) {
            享元池.put(分类键, new 具体网站(分类键));
        }
        return 享元池.get(分类键);
    }

    public int 获取网站数量() {
        return 享元池.size();
    }
}

public class 主类 {
    public static void main(String[] args) {
        网站工厂 工厂 = new 网站工厂();

        网站 网站对象1 = 工厂.获取网站分类("产品展示");
        网站对象1.使用(new 用户("小菜"));

        网站 网站对象2 = 工厂.获取网站分类("产品展示");
        网站对象2.使用(new 用户("大鸟"));

        网站 网站对象3 = 工厂.获取网站分类("产品展示");
        网站对象3.使用(new 用户("娇娇"));

        网站 网站对象4 = 工厂.获取网站分类("博客");
        网站对象4.使用(new 用户("老顽童"));

        网站 网站对象5 = 工厂.获取网站分类("博客");
        网站对象5.使用(new 用户("桃谷六仙"));

        网站 网站对象6 = 工厂.获取网站分类("博客");
        网站对象6.使用(new 用户("南海鳄神"));

        System.out.println("得到网站分类总数为 " + 工厂.获取网站数量());
    }
}

```

### **结构组成**

![image-20221017164911912](img/flyweight/flyweight.jpg)

## 模式评价

**适合场景**

一个是程序中大量的对象造成了较大的存储开销。另一个是对象的大多数状态可以外部状态，如果删除对象的外部状态，就可以用相对较少的共享对象取代很多组对象。

**实际应用**

1.jdk 中基本类型的包装类的缓存机制。

2.数据库连接池等池化技术也运用了享元模式的思想。

**模式优点**

实现代码和资源的共享，减少了维护成本

</AppTab>
<AppTab label="💡 解读">


想象你开了一家印刷厂，很多客户都要求印名片。每个客户的名片内容不同（姓名、职位、电话等），但名片的设计模板（颜色、字体、布局）其实只有几种。享元模式就是让你把可共享的部分（模板）和不可共享的部分（个人信息）分开存储，避免为每个客户都创建全新的设计模板。

## 技术深入解析

### 问题本质

在网站开发场景中：

- **内部状态**（可共享）：网站的基本框架、布局、功能模块（如博客系统的文章发布功能）
- **外部状态**（不可共享）：用户特定的内容、个性化设置

### 模式组成解析

1. **Flyweight（网站抽象类）**

   - 定义所有具体享元类的接口
   - 包含使用外部状态的方法（`使用(用户)`）

2. **ConcreteFlyweight（具体网站类）**

   - 实现具体功能（如博客系统、产品展示系统）
   - 存储内部状态（网站类型名称）

3. **FlyweightFactory（网站工厂）**

   - 维护享元池（HashMap）
   - 实现对象复用逻辑（首次创建，后续复用）

4. **Client（主类）**
   - 维护外部状态（用户信息）
   - 调用享元对象

### 代码深度分析

```java
// 关键点1：享元池的实现
private Map<String,网站> 享元池 = new HashMap<>();

// 关键点2：对象复用逻辑
public 网站 获取网站分类(String 分类键) {
    if(!享元池.containsKey(分类键)) {
        享元池.put(分类键, new 具体网站(分类键)); // 不存在则创建
    }
    return 享元池.get(分类键); // 存在则直接返回
}
```

这段代码展示了享元模式的核心：

- 使用 Map 作为对象池
- 通过键值（网站类型）管理对象
- 确保同类型网站只创建一次

### 性能优化分析

假设有 1000 个用户：

- 传统方式：创建 1000 个网站实例
- 享元模式：只需创建 N 个网站类型实例（N<<1000）
- 内存节省：显著减少对象数量

## 架构师视角的思考

### 设计考量

1. **对象粒度的划分**

   - 需要合理区分内部状态和外部状态
   - 过度共享会导致外部状态复杂化

2. **线程安全性**

   - 享元工厂需要考虑并发访问
   - 享元对象本身通常是无状态的

3. **缓存策略**
   - 何时清理不常用的享元对象
   - 可考虑 LRU 等缓存淘汰策略

### 实际应用扩展

1. **Web 开发中的模板引擎**

   - 模板是共享的（内部状态）
   - 数据是特定的（外部状态）

2. **游戏开发**

   - 树木、建筑等场景元素的共享
   - 位置、旋转等作为外部状态

3. **文字处理系统**
   - 字符对象共享字形信息
   - 位置、颜色作为外部属性

## 备考要点

1. **模式识别**

   - 大量相似对象
   - 对象状态可分内外
   - 需要减少内存占用

2. **UML 图示**

   - 重点记忆工厂与享元的关系
   - 理解非共享享元的特殊位置

3. **对比其他模式**

   - 与单例模式：享元是多例的
   - 与对象池：享元更关注状态分离

4. **性能影响**
   - 空间效率提升
   - 可能增加时间开销（查找享元）

通过这种理解方式，你可以在系统架构设计中灵活运用享元模式，特别是在需要优化资源使用的场景中。

</AppTab>
</AppTabs>